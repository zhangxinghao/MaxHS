// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: banyan_go_types.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_banyan_5fgo_5ftypes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_banyan_5fgo_5ftypes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_banyan_5fgo_5ftypes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_banyan_5fgo_5ftypes_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[7]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_banyan_5fgo_5ftypes_2eproto;
namespace banyan {
class HardClause;
struct HardClauseDefaultTypeInternal;
extern HardClauseDefaultTypeInternal _HardClause_default_instance_;
class Problem;
struct ProblemDefaultTypeInternal;
extern ProblemDefaultTypeInternal _Problem_default_instance_;
class Problems;
struct ProblemsDefaultTypeInternal;
extern ProblemsDefaultTypeInternal _Problems_default_instance_;
class Result;
struct ResultDefaultTypeInternal;
extern ResultDefaultTypeInternal _Result_default_instance_;
class Results;
struct ResultsDefaultTypeInternal;
extern ResultsDefaultTypeInternal _Results_default_instance_;
class Results_ClusterRstEntry_DoNotUse;
struct Results_ClusterRstEntry_DoNotUseDefaultTypeInternal;
extern Results_ClusterRstEntry_DoNotUseDefaultTypeInternal _Results_ClusterRstEntry_DoNotUse_default_instance_;
class SoftClause;
struct SoftClauseDefaultTypeInternal;
extern SoftClauseDefaultTypeInternal _SoftClause_default_instance_;
}  // namespace banyan
PROTOBUF_NAMESPACE_OPEN
template<> ::banyan::HardClause* Arena::CreateMaybeMessage<::banyan::HardClause>(Arena*);
template<> ::banyan::Problem* Arena::CreateMaybeMessage<::banyan::Problem>(Arena*);
template<> ::banyan::Problems* Arena::CreateMaybeMessage<::banyan::Problems>(Arena*);
template<> ::banyan::Result* Arena::CreateMaybeMessage<::banyan::Result>(Arena*);
template<> ::banyan::Results* Arena::CreateMaybeMessage<::banyan::Results>(Arena*);
template<> ::banyan::Results_ClusterRstEntry_DoNotUse* Arena::CreateMaybeMessage<::banyan::Results_ClusterRstEntry_DoNotUse>(Arena*);
template<> ::banyan::SoftClause* Arena::CreateMaybeMessage<::banyan::SoftClause>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace banyan {

// ===================================================================

class HardClause final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:banyan.HardClause) */ {
 public:
  inline HardClause() : HardClause(nullptr) {}
  ~HardClause() override;
  explicit constexpr HardClause(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HardClause(const HardClause& from);
  HardClause(HardClause&& from) noexcept
    : HardClause() {
    *this = ::std::move(from);
  }

  inline HardClause& operator=(const HardClause& from) {
    CopyFrom(from);
    return *this;
  }
  inline HardClause& operator=(HardClause&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HardClause& default_instance() {
    return *internal_default_instance();
  }
  static inline const HardClause* internal_default_instance() {
    return reinterpret_cast<const HardClause*>(
               &_HardClause_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HardClause& a, HardClause& b) {
    a.Swap(&b);
  }
  inline void Swap(HardClause* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HardClause* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HardClause* New() const final {
    return new HardClause();
  }

  HardClause* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HardClause>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HardClause& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HardClause& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HardClause* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "banyan.HardClause";
  }
  protected:
  explicit HardClause(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLitsFieldNumber = 2,
  };
  // repeated int32 lits = 2;
  int lits_size() const;
  private:
  int _internal_lits_size() const;
  public:
  void clear_lits();
  private:
  int32_t _internal_lits(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_lits() const;
  void _internal_add_lits(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_lits();
  public:
  int32_t lits(int index) const;
  void set_lits(int index, int32_t value);
  void add_lits(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      lits() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_lits();

  // @@protoc_insertion_point(class_scope:banyan.HardClause)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > lits_;
  mutable std::atomic<int> _lits_cached_byte_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_banyan_5fgo_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class SoftClause final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:banyan.SoftClause) */ {
 public:
  inline SoftClause() : SoftClause(nullptr) {}
  ~SoftClause() override;
  explicit constexpr SoftClause(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SoftClause(const SoftClause& from);
  SoftClause(SoftClause&& from) noexcept
    : SoftClause() {
    *this = ::std::move(from);
  }

  inline SoftClause& operator=(const SoftClause& from) {
    CopyFrom(from);
    return *this;
  }
  inline SoftClause& operator=(SoftClause&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SoftClause& default_instance() {
    return *internal_default_instance();
  }
  static inline const SoftClause* internal_default_instance() {
    return reinterpret_cast<const SoftClause*>(
               &_SoftClause_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SoftClause& a, SoftClause& b) {
    a.Swap(&b);
  }
  inline void Swap(SoftClause* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SoftClause* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SoftClause* New() const final {
    return new SoftClause();
  }

  SoftClause* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SoftClause>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SoftClause& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SoftClause& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SoftClause* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "banyan.SoftClause";
  }
  protected:
  explicit SoftClause(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLitsFieldNumber = 2,
    kWeightFieldNumber = 1,
  };
  // repeated int32 lits = 2;
  int lits_size() const;
  private:
  int _internal_lits_size() const;
  public:
  void clear_lits();
  private:
  int32_t _internal_lits(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_lits() const;
  void _internal_add_lits(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_lits();
  public:
  int32_t lits(int index) const;
  void set_lits(int index, int32_t value);
  void add_lits(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      lits() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_lits();

  // int32 weight = 1;
  void clear_weight();
  int32_t weight() const;
  void set_weight(int32_t value);
  private:
  int32_t _internal_weight() const;
  void _internal_set_weight(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:banyan.SoftClause)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > lits_;
  mutable std::atomic<int> _lits_cached_byte_size_;
  int32_t weight_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_banyan_5fgo_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class Problem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:banyan.Problem) */ {
 public:
  inline Problem() : Problem(nullptr) {}
  ~Problem() override;
  explicit constexpr Problem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Problem(const Problem& from);
  Problem(Problem&& from) noexcept
    : Problem() {
    *this = ::std::move(from);
  }

  inline Problem& operator=(const Problem& from) {
    CopyFrom(from);
    return *this;
  }
  inline Problem& operator=(Problem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Problem& default_instance() {
    return *internal_default_instance();
  }
  static inline const Problem* internal_default_instance() {
    return reinterpret_cast<const Problem*>(
               &_Problem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Problem& a, Problem& b) {
    a.Swap(&b);
  }
  inline void Swap(Problem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Problem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Problem* New() const final {
    return new Problem();
  }

  Problem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Problem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Problem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Problem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Problem* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "banyan.Problem";
  }
  protected:
  explicit Problem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHardClausesFieldNumber = 5,
    kSoftClausesFieldNumber = 6,
    kClusterIdFieldNumber = 1,
    kNumVarsFieldNumber = 2,
    kNumClausesFieldNumber = 3,
    kTopWeightFieldNumber = 4,
  };
  // repeated .banyan.HardClause hardClauses = 5;
  int hardclauses_size() const;
  private:
  int _internal_hardclauses_size() const;
  public:
  void clear_hardclauses();
  ::banyan::HardClause* mutable_hardclauses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::banyan::HardClause >*
      mutable_hardclauses();
  private:
  const ::banyan::HardClause& _internal_hardclauses(int index) const;
  ::banyan::HardClause* _internal_add_hardclauses();
  public:
  const ::banyan::HardClause& hardclauses(int index) const;
  ::banyan::HardClause* add_hardclauses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::banyan::HardClause >&
      hardclauses() const;

  // repeated .banyan.SoftClause softClauses = 6;
  int softclauses_size() const;
  private:
  int _internal_softclauses_size() const;
  public:
  void clear_softclauses();
  ::banyan::SoftClause* mutable_softclauses(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::banyan::SoftClause >*
      mutable_softclauses();
  private:
  const ::banyan::SoftClause& _internal_softclauses(int index) const;
  ::banyan::SoftClause* _internal_add_softclauses();
  public:
  const ::banyan::SoftClause& softclauses(int index) const;
  ::banyan::SoftClause* add_softclauses();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::banyan::SoftClause >&
      softclauses() const;

  // int32 clusterId = 1;
  void clear_clusterid();
  int32_t clusterid() const;
  void set_clusterid(int32_t value);
  private:
  int32_t _internal_clusterid() const;
  void _internal_set_clusterid(int32_t value);
  public:

  // int32 numVars = 2;
  void clear_numvars();
  int32_t numvars() const;
  void set_numvars(int32_t value);
  private:
  int32_t _internal_numvars() const;
  void _internal_set_numvars(int32_t value);
  public:

  // int32 numClauses = 3;
  void clear_numclauses();
  int32_t numclauses() const;
  void set_numclauses(int32_t value);
  private:
  int32_t _internal_numclauses() const;
  void _internal_set_numclauses(int32_t value);
  public:

  // int32 topWeight = 4;
  void clear_topweight();
  int32_t topweight() const;
  void set_topweight(int32_t value);
  private:
  int32_t _internal_topweight() const;
  void _internal_set_topweight(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:banyan.Problem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::banyan::HardClause > hardclauses_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::banyan::SoftClause > softclauses_;
  int32_t clusterid_;
  int32_t numvars_;
  int32_t numclauses_;
  int32_t topweight_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_banyan_5fgo_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class Problems final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:banyan.Problems) */ {
 public:
  inline Problems() : Problems(nullptr) {}
  ~Problems() override;
  explicit constexpr Problems(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Problems(const Problems& from);
  Problems(Problems&& from) noexcept
    : Problems() {
    *this = ::std::move(from);
  }

  inline Problems& operator=(const Problems& from) {
    CopyFrom(from);
    return *this;
  }
  inline Problems& operator=(Problems&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Problems& default_instance() {
    return *internal_default_instance();
  }
  static inline const Problems* internal_default_instance() {
    return reinterpret_cast<const Problems*>(
               &_Problems_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Problems& a, Problems& b) {
    a.Swap(&b);
  }
  inline void Swap(Problems* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Problems* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Problems* New() const final {
    return new Problems();
  }

  Problems* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Problems>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Problems& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Problems& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Problems* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "banyan.Problems";
  }
  protected:
  explicit Problems(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProblemsFieldNumber = 1,
  };
  // repeated .banyan.Problem problems = 1;
  int problems_size() const;
  private:
  int _internal_problems_size() const;
  public:
  void clear_problems();
  ::banyan::Problem* mutable_problems(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::banyan::Problem >*
      mutable_problems();
  private:
  const ::banyan::Problem& _internal_problems(int index) const;
  ::banyan::Problem* _internal_add_problems();
  public:
  const ::banyan::Problem& problems(int index) const;
  ::banyan::Problem* add_problems();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::banyan::Problem >&
      problems() const;

  // @@protoc_insertion_point(class_scope:banyan.Problems)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::banyan::Problem > problems_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_banyan_5fgo_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class Result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:banyan.Result) */ {
 public:
  inline Result() : Result(nullptr) {}
  ~Result() override;
  explicit constexpr Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Result(const Result& from);
  Result(Result&& from) noexcept
    : Result() {
    *this = ::std::move(from);
  }

  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline Result& operator=(Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const Result* internal_default_instance() {
    return reinterpret_cast<const Result*>(
               &_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Result& a, Result& b) {
    a.Swap(&b);
  }
  inline void Swap(Result* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Result* New() const final {
    return new Result();
  }

  Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "banyan.Result";
  }
  protected:
  explicit Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLitsFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // repeated int32 lits = 2;
  int lits_size() const;
  private:
  int _internal_lits_size() const;
  public:
  void clear_lits();
  private:
  int32_t _internal_lits(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_lits() const;
  void _internal_add_lits(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_lits();
  public:
  int32_t lits(int index) const;
  void set_lits(int index, int32_t value);
  void add_lits(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      lits() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_lits();

  // int32 status = 1;
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:banyan.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > lits_;
  mutable std::atomic<int> _lits_cached_byte_size_;
  int32_t status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_banyan_5fgo_5ftypes_2eproto;
};
// -------------------------------------------------------------------

class Results_ClusterRstEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Results_ClusterRstEntry_DoNotUse, 
    int32_t, ::banyan::Result,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Results_ClusterRstEntry_DoNotUse, 
    int32_t, ::banyan::Result,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Results_ClusterRstEntry_DoNotUse();
  explicit constexpr Results_ClusterRstEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Results_ClusterRstEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Results_ClusterRstEntry_DoNotUse& other);
  static const Results_ClusterRstEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Results_ClusterRstEntry_DoNotUse*>(&_Results_ClusterRstEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Results final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:banyan.Results) */ {
 public:
  inline Results() : Results(nullptr) {}
  ~Results() override;
  explicit constexpr Results(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Results(const Results& from);
  Results(Results&& from) noexcept
    : Results() {
    *this = ::std::move(from);
  }

  inline Results& operator=(const Results& from) {
    CopyFrom(from);
    return *this;
  }
  inline Results& operator=(Results&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Results& default_instance() {
    return *internal_default_instance();
  }
  static inline const Results* internal_default_instance() {
    return reinterpret_cast<const Results*>(
               &_Results_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Results& a, Results& b) {
    a.Swap(&b);
  }
  inline void Swap(Results* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Results* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Results* New() const final {
    return new Results();
  }

  Results* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Results>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Results& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Results& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Results* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "banyan.Results";
  }
  protected:
  explicit Results(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kClusterRstFieldNumber = 1,
  };
  // map<int32, .banyan.Result> clusterRst = 1;
  int clusterrst_size() const;
  private:
  int _internal_clusterrst_size() const;
  public:
  void clear_clusterrst();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::banyan::Result >&
      _internal_clusterrst() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::banyan::Result >*
      _internal_mutable_clusterrst();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::banyan::Result >&
      clusterrst() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::banyan::Result >*
      mutable_clusterrst();

  // @@protoc_insertion_point(class_scope:banyan.Results)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Results_ClusterRstEntry_DoNotUse,
      int32_t, ::banyan::Result,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> clusterrst_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_banyan_5fgo_5ftypes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HardClause

// repeated int32 lits = 2;
inline int HardClause::_internal_lits_size() const {
  return lits_.size();
}
inline int HardClause::lits_size() const {
  return _internal_lits_size();
}
inline void HardClause::clear_lits() {
  lits_.Clear();
}
inline int32_t HardClause::_internal_lits(int index) const {
  return lits_.Get(index);
}
inline int32_t HardClause::lits(int index) const {
  // @@protoc_insertion_point(field_get:banyan.HardClause.lits)
  return _internal_lits(index);
}
inline void HardClause::set_lits(int index, int32_t value) {
  lits_.Set(index, value);
  // @@protoc_insertion_point(field_set:banyan.HardClause.lits)
}
inline void HardClause::_internal_add_lits(int32_t value) {
  lits_.Add(value);
}
inline void HardClause::add_lits(int32_t value) {
  _internal_add_lits(value);
  // @@protoc_insertion_point(field_add:banyan.HardClause.lits)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
HardClause::_internal_lits() const {
  return lits_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
HardClause::lits() const {
  // @@protoc_insertion_point(field_list:banyan.HardClause.lits)
  return _internal_lits();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
HardClause::_internal_mutable_lits() {
  return &lits_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
HardClause::mutable_lits() {
  // @@protoc_insertion_point(field_mutable_list:banyan.HardClause.lits)
  return _internal_mutable_lits();
}

// -------------------------------------------------------------------

// SoftClause

// int32 weight = 1;
inline void SoftClause::clear_weight() {
  weight_ = 0;
}
inline int32_t SoftClause::_internal_weight() const {
  return weight_;
}
inline int32_t SoftClause::weight() const {
  // @@protoc_insertion_point(field_get:banyan.SoftClause.weight)
  return _internal_weight();
}
inline void SoftClause::_internal_set_weight(int32_t value) {
  
  weight_ = value;
}
inline void SoftClause::set_weight(int32_t value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:banyan.SoftClause.weight)
}

// repeated int32 lits = 2;
inline int SoftClause::_internal_lits_size() const {
  return lits_.size();
}
inline int SoftClause::lits_size() const {
  return _internal_lits_size();
}
inline void SoftClause::clear_lits() {
  lits_.Clear();
}
inline int32_t SoftClause::_internal_lits(int index) const {
  return lits_.Get(index);
}
inline int32_t SoftClause::lits(int index) const {
  // @@protoc_insertion_point(field_get:banyan.SoftClause.lits)
  return _internal_lits(index);
}
inline void SoftClause::set_lits(int index, int32_t value) {
  lits_.Set(index, value);
  // @@protoc_insertion_point(field_set:banyan.SoftClause.lits)
}
inline void SoftClause::_internal_add_lits(int32_t value) {
  lits_.Add(value);
}
inline void SoftClause::add_lits(int32_t value) {
  _internal_add_lits(value);
  // @@protoc_insertion_point(field_add:banyan.SoftClause.lits)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SoftClause::_internal_lits() const {
  return lits_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SoftClause::lits() const {
  // @@protoc_insertion_point(field_list:banyan.SoftClause.lits)
  return _internal_lits();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SoftClause::_internal_mutable_lits() {
  return &lits_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SoftClause::mutable_lits() {
  // @@protoc_insertion_point(field_mutable_list:banyan.SoftClause.lits)
  return _internal_mutable_lits();
}

// -------------------------------------------------------------------

// Problem

// int32 clusterId = 1;
inline void Problem::clear_clusterid() {
  clusterid_ = 0;
}
inline int32_t Problem::_internal_clusterid() const {
  return clusterid_;
}
inline int32_t Problem::clusterid() const {
  // @@protoc_insertion_point(field_get:banyan.Problem.clusterId)
  return _internal_clusterid();
}
inline void Problem::_internal_set_clusterid(int32_t value) {
  
  clusterid_ = value;
}
inline void Problem::set_clusterid(int32_t value) {
  _internal_set_clusterid(value);
  // @@protoc_insertion_point(field_set:banyan.Problem.clusterId)
}

// int32 numVars = 2;
inline void Problem::clear_numvars() {
  numvars_ = 0;
}
inline int32_t Problem::_internal_numvars() const {
  return numvars_;
}
inline int32_t Problem::numvars() const {
  // @@protoc_insertion_point(field_get:banyan.Problem.numVars)
  return _internal_numvars();
}
inline void Problem::_internal_set_numvars(int32_t value) {
  
  numvars_ = value;
}
inline void Problem::set_numvars(int32_t value) {
  _internal_set_numvars(value);
  // @@protoc_insertion_point(field_set:banyan.Problem.numVars)
}

// int32 numClauses = 3;
inline void Problem::clear_numclauses() {
  numclauses_ = 0;
}
inline int32_t Problem::_internal_numclauses() const {
  return numclauses_;
}
inline int32_t Problem::numclauses() const {
  // @@protoc_insertion_point(field_get:banyan.Problem.numClauses)
  return _internal_numclauses();
}
inline void Problem::_internal_set_numclauses(int32_t value) {
  
  numclauses_ = value;
}
inline void Problem::set_numclauses(int32_t value) {
  _internal_set_numclauses(value);
  // @@protoc_insertion_point(field_set:banyan.Problem.numClauses)
}

// int32 topWeight = 4;
inline void Problem::clear_topweight() {
  topweight_ = 0;
}
inline int32_t Problem::_internal_topweight() const {
  return topweight_;
}
inline int32_t Problem::topweight() const {
  // @@protoc_insertion_point(field_get:banyan.Problem.topWeight)
  return _internal_topweight();
}
inline void Problem::_internal_set_topweight(int32_t value) {
  
  topweight_ = value;
}
inline void Problem::set_topweight(int32_t value) {
  _internal_set_topweight(value);
  // @@protoc_insertion_point(field_set:banyan.Problem.topWeight)
}

// repeated .banyan.HardClause hardClauses = 5;
inline int Problem::_internal_hardclauses_size() const {
  return hardclauses_.size();
}
inline int Problem::hardclauses_size() const {
  return _internal_hardclauses_size();
}
inline void Problem::clear_hardclauses() {
  hardclauses_.Clear();
}
inline ::banyan::HardClause* Problem::mutable_hardclauses(int index) {
  // @@protoc_insertion_point(field_mutable:banyan.Problem.hardClauses)
  return hardclauses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::banyan::HardClause >*
Problem::mutable_hardclauses() {
  // @@protoc_insertion_point(field_mutable_list:banyan.Problem.hardClauses)
  return &hardclauses_;
}
inline const ::banyan::HardClause& Problem::_internal_hardclauses(int index) const {
  return hardclauses_.Get(index);
}
inline const ::banyan::HardClause& Problem::hardclauses(int index) const {
  // @@protoc_insertion_point(field_get:banyan.Problem.hardClauses)
  return _internal_hardclauses(index);
}
inline ::banyan::HardClause* Problem::_internal_add_hardclauses() {
  return hardclauses_.Add();
}
inline ::banyan::HardClause* Problem::add_hardclauses() {
  ::banyan::HardClause* _add = _internal_add_hardclauses();
  // @@protoc_insertion_point(field_add:banyan.Problem.hardClauses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::banyan::HardClause >&
Problem::hardclauses() const {
  // @@protoc_insertion_point(field_list:banyan.Problem.hardClauses)
  return hardclauses_;
}

// repeated .banyan.SoftClause softClauses = 6;
inline int Problem::_internal_softclauses_size() const {
  return softclauses_.size();
}
inline int Problem::softclauses_size() const {
  return _internal_softclauses_size();
}
inline void Problem::clear_softclauses() {
  softclauses_.Clear();
}
inline ::banyan::SoftClause* Problem::mutable_softclauses(int index) {
  // @@protoc_insertion_point(field_mutable:banyan.Problem.softClauses)
  return softclauses_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::banyan::SoftClause >*
Problem::mutable_softclauses() {
  // @@protoc_insertion_point(field_mutable_list:banyan.Problem.softClauses)
  return &softclauses_;
}
inline const ::banyan::SoftClause& Problem::_internal_softclauses(int index) const {
  return softclauses_.Get(index);
}
inline const ::banyan::SoftClause& Problem::softclauses(int index) const {
  // @@protoc_insertion_point(field_get:banyan.Problem.softClauses)
  return _internal_softclauses(index);
}
inline ::banyan::SoftClause* Problem::_internal_add_softclauses() {
  return softclauses_.Add();
}
inline ::banyan::SoftClause* Problem::add_softclauses() {
  ::banyan::SoftClause* _add = _internal_add_softclauses();
  // @@protoc_insertion_point(field_add:banyan.Problem.softClauses)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::banyan::SoftClause >&
Problem::softclauses() const {
  // @@protoc_insertion_point(field_list:banyan.Problem.softClauses)
  return softclauses_;
}

// -------------------------------------------------------------------

// Problems

// repeated .banyan.Problem problems = 1;
inline int Problems::_internal_problems_size() const {
  return problems_.size();
}
inline int Problems::problems_size() const {
  return _internal_problems_size();
}
inline void Problems::clear_problems() {
  problems_.Clear();
}
inline ::banyan::Problem* Problems::mutable_problems(int index) {
  // @@protoc_insertion_point(field_mutable:banyan.Problems.problems)
  return problems_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::banyan::Problem >*
Problems::mutable_problems() {
  // @@protoc_insertion_point(field_mutable_list:banyan.Problems.problems)
  return &problems_;
}
inline const ::banyan::Problem& Problems::_internal_problems(int index) const {
  return problems_.Get(index);
}
inline const ::banyan::Problem& Problems::problems(int index) const {
  // @@protoc_insertion_point(field_get:banyan.Problems.problems)
  return _internal_problems(index);
}
inline ::banyan::Problem* Problems::_internal_add_problems() {
  return problems_.Add();
}
inline ::banyan::Problem* Problems::add_problems() {
  ::banyan::Problem* _add = _internal_add_problems();
  // @@protoc_insertion_point(field_add:banyan.Problems.problems)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::banyan::Problem >&
Problems::problems() const {
  // @@protoc_insertion_point(field_list:banyan.Problems.problems)
  return problems_;
}

// -------------------------------------------------------------------

// Result

// int32 status = 1;
inline void Result::clear_status() {
  status_ = 0;
}
inline int32_t Result::_internal_status() const {
  return status_;
}
inline int32_t Result::status() const {
  // @@protoc_insertion_point(field_get:banyan.Result.status)
  return _internal_status();
}
inline void Result::_internal_set_status(int32_t value) {
  
  status_ = value;
}
inline void Result::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:banyan.Result.status)
}

// repeated int32 lits = 2;
inline int Result::_internal_lits_size() const {
  return lits_.size();
}
inline int Result::lits_size() const {
  return _internal_lits_size();
}
inline void Result::clear_lits() {
  lits_.Clear();
}
inline int32_t Result::_internal_lits(int index) const {
  return lits_.Get(index);
}
inline int32_t Result::lits(int index) const {
  // @@protoc_insertion_point(field_get:banyan.Result.lits)
  return _internal_lits(index);
}
inline void Result::set_lits(int index, int32_t value) {
  lits_.Set(index, value);
  // @@protoc_insertion_point(field_set:banyan.Result.lits)
}
inline void Result::_internal_add_lits(int32_t value) {
  lits_.Add(value);
}
inline void Result::add_lits(int32_t value) {
  _internal_add_lits(value);
  // @@protoc_insertion_point(field_add:banyan.Result.lits)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Result::_internal_lits() const {
  return lits_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
Result::lits() const {
  // @@protoc_insertion_point(field_list:banyan.Result.lits)
  return _internal_lits();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Result::_internal_mutable_lits() {
  return &lits_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
Result::mutable_lits() {
  // @@protoc_insertion_point(field_mutable_list:banyan.Result.lits)
  return _internal_mutable_lits();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Results

// map<int32, .banyan.Result> clusterRst = 1;
inline int Results::_internal_clusterrst_size() const {
  return clusterrst_.size();
}
inline int Results::clusterrst_size() const {
  return _internal_clusterrst_size();
}
inline void Results::clear_clusterrst() {
  clusterrst_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::banyan::Result >&
Results::_internal_clusterrst() const {
  return clusterrst_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::banyan::Result >&
Results::clusterrst() const {
  // @@protoc_insertion_point(field_map:banyan.Results.clusterRst)
  return _internal_clusterrst();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::banyan::Result >*
Results::_internal_mutable_clusterrst() {
  return clusterrst_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::banyan::Result >*
Results::mutable_clusterrst() {
  // @@protoc_insertion_point(field_mutable_map:banyan.Results.clusterRst)
  return _internal_mutable_clusterrst();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace banyan

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_banyan_5fgo_5ftypes_2eproto
